<!DOCTYPE html>
<html lang="th">

<head>
  <meta charset="utf-8" />
  <title>Portfolio</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,
    body {
      height: 100%;
      margin: 0
    }

    canvas {
      display: block
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
</head>

<body>
  <script>
    // --- Scene / Camera / Renderer ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 100);
    camera.position.set(2, 1, -3);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // --- Lights ---
    const hemi = new THREE.HemisphereLight(0xffffff, 0x333333, 0.6);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(3, 5, 2);
    dir.castShadow = true;
    scene.add(dir);

    // --- Ground ---
    const ground = new THREE.Mesh(
      new THREE.PlaneBufferGeometry(10, 10),
      new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.95, metalness: 0.0 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // --- Upgrade env with equirect (PMREM) ---
    const pmrem = new THREE.PMREMGenerator(renderer);
    pmrem.compileEquirectangularShader();
    new THREE.TextureLoader().load(
      'https://sitapich-t.github.io/icg/final-project/kloppenheim_02.jpg',
      (tex) => {
        tex.mapping = THREE.EquirectangularReflectionMapping;
        tex.encoding = THREE.SRGBEncoding;
        const envRT = pmrem.fromEquirectangular(tex).texture;
        scene.environment = envRT;   // ‡∏™‡∏∞‡∏ó‡πâ‡∏≠‡∏ô‡∏™‡∏ß‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö PBR
        scene.background = tex;     // ‡∏â‡∏≤‡∏Å‡∏´‡∏•‡∏±‡∏á‡∏ä‡∏±‡∏î (‡∏ñ‡πâ‡∏≤‡∏≠‡∏¢‡∏≤‡∏Å‡πÄ‡∏ö‡∏•‡∏≠ ‡πÉ‡∏ä‡πâ envRT ‡πÅ‡∏ó‡∏ô)

        if (ball && ball.material) {
          ball.material.envMap = envRT;
          ball.material.needsUpdate = true;
        }

        pmrem.dispose();
      },
      undefined,
      (err) => console.error('‡πÇ‡∏´‡∏•‡∏î JPG environment ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à:', err)
    );

    // --- Grid helper ---
    const grid = new THREE.GridHelper(10, 10, 0x666666, 0x333333);
    grid.position.y = -0.001;
    scene.add(grid);

    // --- References we need later ---
    let abtmeModel = null;
    let imgMesh = null;
    let nameModel = null;
    let backModel = null;
    let backModel2 = null;
    let wetSignModel = null;
    let workModel = null;
    let nextModel = null;
    let nextModel2 = null;
    let ball = null;
    let torusMesh = null;
    let vertShader = null;

    // --- Apartment model ---
    const gltfLoader = new THREE.GLTFLoader();
    gltfLoader.load(
      'https://sitapich-t.github.io/icg/final-project/apartment_floor_plan.glb',
      (gltf) => {
        const apmtModel = gltf.scene || gltf.scenes[0];
        apmtModel.traverse((node) => {
          if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;
            if (node.material && (node.material.isMeshStandardMaterial || node.material.isMeshPhysicalMaterial)) {
              node.material.needsUpdate = true;
            }
          }
        });
        apmtModel.position.set(2, -1.2, 0);
        apmtModel.scale.set(0.5, 0.5, 0.5);
        scene.add(apmtModel);
      },
      undefined,
      (error) => console.error('Error loading apartment glTF:', error)
    );

    const wetSignLoader = new THREE.GLTFLoader();
    wetSignLoader.load(
      'https://sitapich-t.github.io/icg/final-project/wet_floor_sign.glb',
      (gltf) => {
        wetSignModel = gltf.scene || gltf.scenes[0];
        wetSignModel.traverse((node) => {
          if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;
            if (node.material && (node.material.isMeshStandardMaterial || node.material.isMeshPhysicalMaterial)) {
              node.material.needsUpdate = true;
            }
          }
        });
        wetSignModel.position.set(3.8, 0.29, -3.8);
        wetSignModel.scale.set(0.01, 0.01, 0.01);
        wetSignModel.rotation.set(0, 0, 0);
        scene.add(wetSignModel);

        // ‡∏ï‡∏±‡πâ‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÉ‡∏´‡πâ "‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏à‡∏±‡∏ö about me"
        focusCameraTo(
          wetSignModel.position,
          { distance: 2.0, height: 0.6, fromDir: new THREE.Vector3(1, 1, -1) },
          0.8
        );
      },
      undefined,
      (error) => console.error('Error loading name glTF:', error)
    );

    const workLoader = new THREE.GLTFLoader();
    workLoader.load(
      'https://sitapich-t.github.io/icg/final-project/work.glb',
      (gltf) => {
        workModel = gltf.scene || gltf.scenes[0];
        workModel.traverse((node) => {
          if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;
            if (node.material && (node.material.isMeshStandardMaterial || node.material.isMeshPhysicalMaterial)) {
              node.material.needsUpdate = true;
            }
          }
        });

        workModel.position.set(1, 1, -3);
        workModel.scale.set(0.17, 0.17, 0.17);
        workModel.rotation.set(0, -Math.PI / 2, 0);
        scene.add(workModel);
      },
      undefined,
      (error) => console.error('Error loading aboutme glTF:', error)
    );

    // --- About me (target to click) ---
    const abtLoader = new THREE.GLTFLoader();
    abtLoader.load(
      'https://sitapich-t.github.io/icg/final-project/abtme.glb',
      (gltf) => {
        abtmeModel = gltf.scene || gltf.scenes[0];
        abtmeModel.traverse((node) => {
          if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;
            if (node.material && (node.material.isMeshStandardMaterial || node.material.isMeshPhysicalMaterial)) {
              node.material.needsUpdate = true;
            }
          }
        });

        abtmeModel.position.set(1, 1.2, -3);
        abtmeModel.scale.set(0.17, 0.17, 0.17);
        abtmeModel.rotation.set(0, -Math.PI / 2, 0);
        scene.add(abtmeModel);
      },
      undefined,
      (error) => console.error('Error loading aboutme glTF:', error)
    );

    // --- Image (portrait) ---
    const texLoader = new THREE.TextureLoader();
    texLoader.load('https://sitapich-t.github.io/icg/final-project/blink.jpg', (texture) => {
      // ‡πÉ‡∏ä‡πâ BoxGeometry ‡∏Å‡πá‡πÑ‡∏î‡πâ ‡πÅ‡∏ï‡πà‡∏ß‡∏≤‡∏á‡πÉ‡∏à‡πÑ‡∏î‡πâ‡∏ß‡πà‡∏≤‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏à‡∏∞‡∏≠‡∏¢‡∏π‡πà‡∏î‡πâ‡∏≤‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÅ‡∏ô‡πà‡πÜ ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÄ‡∏£‡∏≤‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≤‡∏Å normal ‡∏Ç‡∏≠‡∏á +Z
      const imgGeo = new THREE.BoxGeometry(0.5, 0.5, 0.05);
      const imgMat = new THREE.MeshBasicMaterial({ map: texture });
      imgMesh = new THREE.Mesh(imgGeo, imgMat);
      imgMesh.position.set(4.1, 1.05, 0.45);
      imgMesh.scale.set(1.1, 1.1, 1.1);
      imgMesh.rotation.set(-Math.PI / 2, -Math.PI / 2, -Math.PI / 2);
      imgMesh.castShadow = false;
      imgMesh.receiveShadow = false;
      scene.add(imgMesh);
    });

    // --- Name model ---
    const nameLoader = new THREE.GLTFLoader();
    nameLoader.load(
      'https://sitapich-t.github.io/icg/final-project/name.glb',
      (gltf) => {
        nameModel = gltf.scene || gltf.scenes[0];
        nameModel.traverse((node) => {
          if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;
            if (node.material && (node.material.isMeshStandardMaterial || node.material.isMeshPhysicalMaterial)) {
              node.material.needsUpdate = true;
            }
          }
        });
        nameModel.position.set(4.1, 1.58, 0.2);
        nameModel.scale.set(0.1, 0.1, 0.1);
        nameModel.rotation.set(-Math.PI / 2, Math.PI, -Math.PI / 2);
        scene.add(nameModel);
      },
      undefined,
      (error) => console.error('Error loading name glTF:', error)
    );

    const backLoader = new THREE.GLTFLoader();
    backLoader.load(
      'https://sitapich-t.github.io/icg/final-project/back.glb',
      (gltf) => {
        backModel = gltf.scene || gltf.scenes[0];
        backModel.traverse((node) => {
          if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;
            if (node.material && (node.material.isMeshStandardMaterial || node.material.isMeshPhysicalMaterial)) {
              node.material.needsUpdate = true;
            }
          }
        });
        backModel.position.set(4.1, 0.8, -0.13);
        backModel.scale.set(0.1, 0.1, 0.1);
        scene.add(backModel);
      },
      undefined,
      (error) => console.error('Error loading name glTF:', error)
    );

    const backLoader2 = new THREE.GLTFLoader();
    backLoader2.load(
      'https://sitapich-t.github.io/icg/final-project/back.glb',
      (gltf) => {
        backModel2 = gltf.scene || gltf.scenes[0];
        backModel2.traverse((node) => {
          if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;
            if (node.material && (node.material.isMeshStandardMaterial || node.material.isMeshPhysicalMaterial)) {
              node.material.needsUpdate = true;
            }
          }
        });
        backModel2.position.set(3.65, 0.4, 3.2);
        backModel2.scale.set(0.1, 0.1, 0.1);
        backModel2.rotation.set(0, -Math.PI/2, 0);
        scene.add(backModel2);
      },
      undefined,
      (error) => console.error('Error loading name glTF:', error)
    );

    const nextLoader = new THREE.GLTFLoader();
    nextLoader.load(
      'https://sitapich-t.github.io/icg/final-project/next.glb',
      (gltf) => {
        nextModel = gltf.scene || gltf.scenes[0];
        nextModel.traverse((node) => {
          if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;
            if (node.material && (node.material.isMeshStandardMaterial || node.material.isMeshPhysicalMaterial)) {
              node.material.needsUpdate = true;
            }
          }
        });
        nextModel.position.set(0, 0.75, 0.45);
        nextModel.scale.set(0.1, 0.1, 0.1);
        nextModel.rotation.set(0, Math.PI / 8, 0);
        scene.add(nextModel);
      },
      undefined,
      (error) => console.error('Error loading name glTF:', error)
    );

    const nextLoader2 = new THREE.GLTFLoader();
    nextLoader2.load(
      'https://sitapich-t.github.io/icg/final-project/next.glb',
      (gltf) => {
        nextModel2 = gltf.scene || gltf.scenes[0];
        nextModel2.traverse((node) => {
          if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;
            if (node.material && (node.material.isMeshStandardMaterial || node.material.isMeshPhysicalMaterial)) {
              node.material.needsUpdate = true;
            }
          }
        });
        nextModel2.position.set(-3, 1, -2);
        nextModel2.scale.set(0.1, 0.1, 0.1);
        nextModel2.rotation.set(0, Math.PI / 4, 0);
        scene.add(nextModel2);
      },
      undefined,
      (error) => console.error('Error loading name glTF:', error)
    );

    // ===== Helpers: world-front direction for any object =====
    // ‡∏ô‡∏¥‡∏¢‡∏≤‡∏°: ‡∏î‡πâ‡∏≤‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÉ‡∏ä‡πâ‡πÅ‡∏Å‡∏ô +Z ‡∏Ç‡∏≠‡∏á local object (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤ Plane/Box ‡∏î‡πâ‡∏≤‡∏ô‡∏´‡∏ô‡πâ‡∏≤)
    // ‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏ß‡∏≤‡∏á‡πÑ‡∏õ‡∏ï‡∏≤‡∏°‡∏ó‡∏¥‡∏® -front ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏°‡∏≠‡∏á‡πÄ‡∏Ç‡πâ‡∏≤‡∏´‡∏≤‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏à‡∏≤‡∏Å‡∏î‡πâ‡∏≤‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏™‡∏°‡∏≠
    const _tmpQ = new THREE.Quaternion();
    function getWorldFrontDir(obj) {
      const q = obj.getWorldQuaternion(_tmpQ);
      const localFront = new THREE.Vector3(0, 0, 1); // +Z
      const worldFront = localFront.clone().applyQuaternion(q).normalize();
      return worldFront;
    }

    // --- Simple camera tween (position + controls.target) ---
    let tween = null;
    function focusCameraTo(lookAtVec3, opts = {}, duration = 1.0) {
      const { distance = 2.0, height = 0.0, fromDir = new THREE.Vector3(0, 0, 1) } = opts;

      // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á + ‡∏£‡∏∞‡∏¢‡∏∞ + ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á
      const dirNorm = fromDir.clone().normalize();
      const destPos = new THREE.Vector3(
        lookAtVec3.x + dirNorm.x * distance,
        lookAtVec3.y + height,
        lookAtVec3.z + dirNorm.z * distance
      );

      tween = {
        t: 0,
        d: Math.max(0.001, duration),
        fromPos: camera.position.clone(),
        toPos: destPos,
        fromTarget: controls.target.clone(),
        toTarget: lookAtVec3.clone()
      };
    }

    // --- ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì focus ‡∏Ç‡∏≠‡∏á "‡∏£‡∏π‡∏õ + ‡∏ä‡∏∑‡πà‡∏≠" (‡πÉ‡∏ä‡πâ front ‡∏à‡∏£‡∏¥‡∏á‡∏Ç‡∏≠‡∏á imgMesh) ---
    function getProfileFocus(duration = 1.0) {
      if (!(imgMesh && nameModel)) return null;

      const boxImg = new THREE.Box3().setFromObject(imgMesh);
      const boxName = new THREE.Box3().setFromObject(nameModel);
      const boxAll = boxImg.union(boxName);

      const center = boxAll.getCenter(new THREE.Vector3());
      const size = boxAll.getSize(new THREE.Vector3());
      const maxSize = Math.max(size.x, size.y, size.z);

      const worldFront = getWorldFrontDir(imgMesh);     // ‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏õ‡∏≠‡∏¢‡∏π‡πà "‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°" ‡∏´‡∏ô‡πâ‡∏≤‡∏ô‡∏µ‡πâ
      const fromDir = worldFront.clone();   // ‡∏°‡∏≠‡∏á‡πÄ‡∏Ç‡πâ‡∏≤‡∏´‡∏≤‡∏´‡∏ô‡πâ‡∏≤

      const height = Math.max(0.2, size.y * 0.15);

      const distance = Math.max(1.2, maxSize * 2.0);

      fromDir.y += 0.08;

      return { center, distance, height, fromDir, duration };
    }

    function getBallFocus(duration = 1.0) {
      if (!ball) return null;

      const box = new THREE.Box3().setFromObject(ball);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());
      const maxSize = Math.max(size.x, size.y, size.z);

      // ‡∏°‡∏∏‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÄ‡∏â‡∏µ‡∏¢‡∏á‡∏à‡∏≤‡∏Å‡∏î‡πâ‡∏≤‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢
      const fromDir = new THREE.Vector3(0.6, 0.15, 1).normalize();
      const height = Math.max(0.2, maxSize * 0.2);
      const distance = Math.max(1.2, maxSize * 2.2);

      return { center, distance, height, fromDir, duration };
    }

    function getTorusFocus(duration = 1.0) {
      if (!torusMesh) return null;

      const box = new THREE.Box3().setFromObject(torusMesh);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());
      const maxSize = Math.max(size.x, size.y, size.z);

      // ‡∏°‡∏∏‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÄ‡∏â‡∏µ‡∏¢‡∏á‡∏à‡∏≤‡∏Å‡∏î‡πâ‡∏≤‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢
      const fromDir = new THREE.Vector3(0.6, 0.15, 1).normalize();
      const height = Math.max(0.2, maxSize * 0.2);
      const distance = Math.max(1.2, maxSize * 2.2);

      return { center, distance, height, fromDir, duration };
    }

    function getvertShaderFocus(duration = 1.0) {
      if (!vertShader) return null;

      const box = new THREE.Box3().setFromObject(vertShader);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());
      const maxSize = Math.max(size.x, size.y, size.z);

      // ‡∏°‡∏∏‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÄ‡∏â‡∏µ‡∏¢‡∏á‡∏à‡∏≤‡∏Å‡∏î‡πâ‡∏≤‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢
      const fromDir = new THREE.Vector3(0.6, 0.15, 1).normalize();
      const height = Math.max(0.2, maxSize * 0.2);
      const distance = Math.max(1.2, maxSize * 2.2);

      return { center, distance, height, fromDir, duration };
    }

    // --- Raycaster: ‡∏Ñ‡∏•‡∏¥‡∏Å abtme -> ‡πÇ‡∏ü‡∏Å‡∏±‡∏™‡∏£‡∏π‡∏õ+‡∏ä‡∏∑‡πà‡∏≠ ‡∏î‡πâ‡∏≤‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÅ‡∏ô‡πà‡∏ô‡∏≠‡∏ô ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function flipDir(v) { return v.clone().multiplyScalar(-1); }

    function onPointerDown(e) {
      const rect = renderer.domElement.getBoundingClientRect();
      const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      mouse.set(x, y);

      raycaster.setFromCamera(mouse, camera);

      if (nextModel2 && vertShader) {
        const hitNext2 = raycaster.intersectObject(nextModel2, true);
        if (hitNext2.length > 0) {
          const tf = getvertShaderFocus(1.0);

          const oppositeDir = tf ? tf.fromDir.clone().multiplyScalar(-1) : new THREE.Vector3(-0.6, 0.15, -1);
          const dist = tf ? Math.max(0.5, tf.distance * 0.6) : 1.2; // üëà 0.6 = 60% ‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏î‡∏¥‡∏° (‡πÉ‡∏Å‡∏•‡πâ‡∏Ç‡∏∂‡πâ‡∏ô)
          const h = tf ? tf.height : 0.6;
          const ctr = tf ? tf.center : vertShader.position;
          const dur = tf ? tf.duration : 1.0;

          focusCameraTo(ctr, { distance: dist, height: h, fromDir: oppositeDir }, dur);
          return;
        }
      }

      if (nextModel && torusMesh) {
        const hitNext = raycaster.intersectObject(nextModel, true);
        if (hitNext.length > 0) {
          const tf = getTorusFocus(1.0);
          if (tf) {
            focusCameraTo(
              tf.center,
              { distance: tf.distance, height: tf.height, fromDir: tf.fromDir },
              tf.duration
            );
          } else {
            focusCameraTo(
              torusMesh.position,
              { distance: 2.0, height: 0.6, fromDir: new THREE.Vector3(0.6, 0.15, 1) },
              1.0
            );
          }
          return;
        }
      }

      if (wetSignModel && abtmeModel) {
        const hitWet = raycaster.intersectObject(wetSignModel, true);
        if (hitWet.length > 0) {
          focusCameraTo(
            abtmeModel.position,
            { distance: 2.0, height: 0.6, fromDir: new THREE.Vector3(-1, 0, 1) },
            1.0
          );
          return;
        }
      }

      if (workModel && ball) {
        const hitWork = raycaster.intersectObject(workModel, true);
        if (hitWork.length > 0) {
          const bf = getBallFocus(1.0);
          if (bf) {
            focusCameraTo(
              bf.center,
              { distance: bf.distance, height: bf.height, fromDir: bf.fromDir },
              bf.duration
            );
          } else {
            focusCameraTo(ball.position, { distance: 2.0, height: 0.4, fromDir: new THREE.Vector3(0.6, 0.15, 1) }, 1.0);
          }
          return;
        }
      }

      if (abtmeModel) {
        const hitAbt = raycaster.intersectObject(abtmeModel, true);
        if (hitAbt.length > 0) {
          const prof = getProfileFocus(1.0); // ‡πÉ‡∏ä‡πâ‡∏ï‡∏±‡∏ß‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏î‡∏¥‡∏°‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì
          if (prof) {
            focusCameraTo(
              prof.center,
              { distance: prof.distance, height: prof.height, fromDir: prof.fromDir },
              prof.duration
            );
          } else {
            const fallbackLook = new THREE.Vector3(4.05, 1.28, 0.33);
            focusCameraTo(fallbackLook, { distance: 1.2, height: 0.4, fromDir: new THREE.Vector3(0, 0, -1) }, 1.0);
          }
          return;
        }
      }

      if (backModel && abtmeModel) {
        const hitBack = raycaster.intersectObject(backModel, true);
        if (hitBack.length > 0) {
          focusCameraTo(
            abtmeModel.position,
            { distance: 2.0, height: 0.6, fromDir: new THREE.Vector3(-1, 0, 1) },
            1.0
          );
          return;
        }
      }

      if (backModel2 && abtmeModel) {
        const hitBack2 = raycaster.intersectObject(backModel2, true);
        if (hitBack2.length > 0) {
          focusCameraTo(
            abtmeModel.position,
            { distance: 2.0, height: 0.6, fromDir: new THREE.Vector3(-1, 0, 1) },
            1.0
          );
          return;
        }
      }
    }

    renderer.domElement.addEventListener('pointerdown', onPointerDown);

    ball = new THREE.Mesh(
      new THREE.SphereBufferGeometry(0.65, 64, 64),
      new THREE.MeshStandardMaterial({
        color: 0xffffff,
        metalness: 0.9,
        roughness: 0.1,
        envMapIntensity: 1.0  // ‡∏à‡∏∞‡πÄ‡∏´‡πá‡∏ô‡∏ú‡∏•‡∏ä‡∏±‡∏î‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏≤‡πÄ‡∏ã‡πá‡∏ï envMap ‡∏´‡∏•‡∏±‡∏á PMREM ‡πÇ‡∏´‡∏•‡∏î (‡∏ó‡∏≥‡πÅ‡∏•‡πâ‡∏ß‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô)
      })
    );
    ball.castShadow = true;
    ball.position.set(0, 1, 0);
    ball.scale.set(0.5, 0.5, 0.5);
    scene.add(ball);

    // --- Uniforms (‡∏°‡∏µ texture fallback ‡∏™‡∏µ‡∏Ç‡∏≤‡∏ß 1x1) ---
    const white = new THREE.DataTexture(new Uint8Array([255, 255, 255]), 1, 1, THREE.RGBFormat);
    white.needsUpdate = true;

    const uniforms = {
      uTime: { value: 0.0 },
      uLightDir: { value: new THREE.Vector3(0.4, 1.0, 0.8).normalize() },
      uTex: { value: white }
    };

    // ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡πÇ‡∏´‡∏•‡∏î stripe.jpg ‡∏ñ‡πâ‡∏≤‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏î‡πâ‡∏Ñ‡πà‡∏≠‡∏¢‡∏™‡∏•‡∏±‡∏ö‡∏°‡∏≤‡πÉ‡∏ä‡πâ
    new THREE.TextureLoader().load(
      'https://sitapich-t.github.io/icg/final-project/Checks & Tartans (A).jpeg',
      (tex) => {
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
        uniforms.uTex.value = tex;
      },
      undefined,
      () => { /* ‡∏ñ‡πâ‡∏≤ error ‡∏Å‡πá‡πÉ‡∏ä‡πâ fallback ‡∏ï‡πà‡∏≠‡πÑ‡∏õ */ }
    );

    // --- Shaders ---
    const vert = `
    uniform float uTime;
    varying vec3 vNormal;
    varying vec3 vPosW;
    varying vec2 vUv;

    void main(){
      vec3 pos = position;

      // << ‡πÅ‡∏Å‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏ï‡∏≤‡∏°‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠: ‡∏Ç‡∏¢‡∏±‡∏ö z ‡∏î‡πâ‡∏ß‡∏¢ sine >>
      pos.z += sin(pos.x * 3.14159265 + uTime) * 0.2;

      vUv = uv;
      // normal ‡πÉ‡∏ô world space
      vNormal = normalize(mat3(modelMatrix) * normal);
      // position ‡πÉ‡∏ô world space
      vPosW = (modelMatrix * vec4(pos, 1.0)).xyz;

      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
    }
  `;

    const frag = `
    precision mediump float;
    varying vec3 vNormal;
    uniform vec3 uLightDir;
    varying vec3 vPosW;
    varying vec2 vUv;
    uniform sampler2D uTex;

    void main(){
      // diffuse toon-ish
      float diffuse = clamp(dot(normalize(vNormal), normalize(uLightDir)), 0.0, 1.0);
      float levels = 3.0;
      diffuse = floor(diffuse * levels) / levels;
      diffuse += 0.5;

      // specular step-ish
      vec3 R = reflect(-normalize(uLightDir), normalize(vNormal));
      vec3 V = normalize(cameraPosition - vPosW);
      float specular = max(pow(max(dot(R, V), 0.0), 16.0), 0.0);
      specular = smoothstep(0.4, 0.6, specular);
      if (diffuse <= 0.5) specular = 0.0;

      vec3 base = texture2D(uTex, vUv).rgb;
      vec3 color = base * diffuse + vec3(specular);

      gl_FragColor = vec4(color, 1.0);
    }
  `;

    // --- Geometry / Material / Mesh ---
    // ‡πÉ‡∏ä‡πâ Torus ‡∏û‡∏£‡πâ‡∏≠‡∏° subdivision ‡∏™‡∏π‡∏á‡∏´‡∏ô‡πà‡∏≠‡∏¢‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏´‡πá‡∏ô‡∏Å‡∏≤‡∏£‡∏Ç‡∏¢‡∏±‡∏ö
    const geo = new THREE.TorusBufferGeometry(0.7, 0.2, 128, 256);
    const mat = new THREE.ShaderMaterial({
      vertexShader: vert,
      fragmentShader: frag,
      uniforms: uniforms
      // wireframe: true
    });
    torusMesh = new THREE.Mesh(geo, mat);
    torusMesh.position.set(-3, 1, -3);
    torusMesh.scale.set(0.5, 0.5, 0.5);
    scene.add(torusMesh);

    const uniforms2 = {
      uTime: { value: 0.1 },
      uHeight: { value: null } // texture ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÇ‡∏´‡∏•‡∏î‡∏°‡∏≤
    };
    // ---- Shaders (sample texture ‡πÉ‡∏ô vertex ‡πÅ‡∏•‡πâ‡∏ß‡∏î‡∏±‡∏ô pos.z) ----
    const vert2 = `
    uniform sampler2D uHeight;
    uniform float uTime;

    varying float vH;

    void main(){
      vec3 pos = position;
      float h = texture2D(uHeight, uv).r * sin(uTime) + 1.0; 
      pos.z = pos.z + (h * 0.8);
      vH = h;                             
      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
    }
  `;
    const frag2 = `
    precision mediump float;
    varying float vH;
    void main(){
      // ‡∏£‡∏∞‡∏ö‡∏≤‡∏¢‡∏™‡∏µ‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á: ‡∏î‡∏≥‚Üí‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô‚Üí‡∏ü‡πâ‡∏≤
      gl_FragColor = vec4(0.2*vH, 0.5*vH + 0.2, 1.0*vH + 0.1, 1.0);
    }
  `;

    // ‡πÇ‡∏´‡∏•‡∏î texture ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏≠‡∏¢‡∏™‡∏£‡πâ‡∏≤‡∏á geometry/material ‡πÉ‡∏´‡πâ‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏£‡∏π‡∏õ
    //https://upload.wikimedia.org/wikipedia/commons/7/71/Black.png
    //https://www.shutterstock.com/shutterstock/videos/3608118583/thumb/10.jpg?ip=x480
    new THREE.TextureLoader().load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQ0DY_m-7c3tjtop15ihxcOGXS1VVdK4EyDJfIkVZXI_-Rs9IqSkYrzorod8RACFrD4RO8&usqp=CAU', (tex) => {

      uniforms2.uHeight.value = tex;
      const geo = new THREE.PlaneBufferGeometry(4, 2, 100, 100);
      const mat = new THREE.ShaderMaterial({
        vertexShader: vert2,
        fragmentShader: frag2,
        uniforms: uniforms2,
        //wireframe: true, // ‡πÄ‡∏õ‡∏¥‡∏î‡∏ñ‡πâ‡∏≤‡∏≠‡∏¢‡∏≤‡∏Å‡∏î‡∏π‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á
        side: THREE.DoubleSide

      });

      vertShader = new THREE.Mesh(geo, mat);
      vertShader.position.set(3.8, 0.4, 3.8);
      vertShader.scale.set(0.2, 0.2, 0.2);
      vertShader.rotation.set(-Math.PI / 2, 0, -Math.PI / 2);
      scene.add(vertShader);
    });

    // --- Resize ---
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // --- Animate loop ---
    const clock = new THREE.Clock();
    function loop() {
      const dt = clock.getDelta();
      dir.position.x = 3 + Math.sin(clock.elapsedTime) * 1.0;

      if (tween) {
        tween.t += dt;
        const k = Math.min(1, tween.t / tween.d);
        const e = k < 0.5 ? 2 * k * k : -1 + (4 - 2 * k) * k;
        camera.position.lerpVectors(tween.fromPos, tween.toPos, e);
        controls.target.lerpVectors(tween.fromTarget, tween.toTarget, e);
        if (k >= 1) tween = null;
      }

      uniforms2.uTime.value += 0.05;

      uniforms.uTime.value = clock.getElapsedTime();
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>

</html>