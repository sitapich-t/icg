<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="utf-8" />
    <title>Portfolio</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        .info {
            position: fixed;
            left: 12px;
            top: 10px;
            padding: 6px 10px;
            background: rgba(0, 0, 0, .55);
            color: #fff;
            font: 14px/1.4 system-ui;
            border-radius: 8px;
        }
    </style>

    <!-- Three.js core (r128) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>

    <!-- Controls & Loaders from examples (ต้องใช้เวอร์ชันเดียวกันกับ core) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>

</head>

<body>
    <!-- <div class="info">Orbit: เมาส์ซ้ายหมุน • กลางแพน • ลูกล้อซูม</div> -->

    <script>
        (() => {
            // --- Scene / Camera / Renderer ---
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111318);

            const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
            camera.position.set(2.5, 1.6, 3.5);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(devicePixelRatio);
            renderer.setSize(innerWidth, innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            renderer.outputEncoding = THREE.sRGBEncoding; // r128

            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0.9, 0);
            controls.update();

            // --- Lights ---
            const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.7);
            scene.add(hemi);

            const dir = new THREE.DirectionalLight(0xffffff, 1.0);
            dir.position.set(5, 6, 4);
            dir.castShadow = true;
            dir.shadow.mapSize.set(2048, 2048);
            scene.add(dir);

            // --- Environment Map (Equirect JPG/PNG) ---
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            pmremGenerator.compileEquirectangularShader();

            new THREE.TextureLoader().load(
                'https://sitapich-t.github.io/icg/final-project/4452.jpg', // ต้องเป็นภาพ equirectangular (2:1)
                (tex) => {
                    tex.mapping = THREE.EquirectangularReflectionMapping;
                    tex.encoding = THREE.sRGBEncoding; // r128

                    // ใช้ PMREM เพื่อให้ MeshStandardMaterial สะท้อนแสงถูกต้อง
                    const envMap = pmremGenerator.fromEquirectangular(tex).texture;

                    scene.environment = envMap;  // ใช้เป็น reflection สำหรับวัสดุ PBR
                    scene.background = tex;     // พื้นหลังเป็นภาพเดิม (หรือจะใช้ envMap ก็ได้ถ้าอยากเบลอ)

                    // เก็บกวาดหน่วยความจำ
                    pmremGenerator.dispose();
                    // อย่า tex.dispose() ถ้ายังใช้เป็น background
                },
                undefined,
                (err) => console.error('โหลด JPG environment ไม่สำเร็จ:', err)
            );

            // Grid helper (ถ้ารบกวนสายตา ลบออกได้)
            const grid = new THREE.GridHelper(10, 10, 0x666666, 0x333333);
            grid.position.y = -0.001;
            scene.add(grid);

            // --- Load MTL -> OBJ ---
            const mtlLoader = new THREE.MTLLoader();
            // ตั้ง path ถ้าไฟล์อยู่คนละโฟลเดอร์ เช่น mtlLoader.setPath('/assets/');
            mtlLoader.load('https://sitapich-t.github.io/icg/final-project/home.mtl', (materials) => {
                materials.preload();

                const objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);

                objLoader.load(
                    'https://sitapich-t.github.io/icg/final-project/home.obj',
                    (object) => {
                        // ปรับค่าตามต้องการ
                        object.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                // ถ้าอยากบังคับวัสดุเป็น PBR มาตรฐาน แทนวัสดุจาก MTL:
                                // child.material = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.2, roughness: 0.6 });
                            }
                        });

                        // scale / position (แก้ตามโมเดลจริง)
                        object.scale.set(1, 1, 1);
                        object.position.set(0, 1.45, 0);
                        object.rotation.y = Math.PI * 0.0;

                        scene.add(object);
                    },
                    (xhr) => {
                        // progress (optional)
                        if (xhr.lengthComputable) {
                            const pct = (xhr.loaded / xhr.total * 100).toFixed(1);
                            console.log(`Loading OBJ: ${pct}%`);
                        }
                    },
                    (err) => {
                        console.error('เกิดข้อผิดพลาดตอนโหลด OBJ:', err);
                    }
                );
            }, undefined, (err) => {
                console.error('เกิดข้อผิดพลาดตอนโหลด MTL:', err);
            });

            // --- Resize handler ---
            addEventListener('resize', () => {
                camera.aspect = innerWidth / innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(innerWidth, innerHeight);
            });

            // --- Render loop ---
            (function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            })();
        })();
    </script>
</body>

</html>